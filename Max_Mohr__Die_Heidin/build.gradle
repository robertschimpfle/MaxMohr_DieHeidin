import java.text.SimpleDateFormat

apply plugin: "sonar"

def srcDir = 'src/main/latex'
def buildSrcDir = 'build'

// Buchstaben.
def b = 'a-zA-ZÄÖÜäöüß'

task prepare(type: Exec) {
	commandLine 'mkdir', '-p', 'build'
}

task clean(type: Exec, dependsOn: prepare) {
	commandLine 'rm', '-rf', 'build'
}

task replaceVersionInfo(type: Copy, dependsOn: clean) {
	from srcDir
	into buildSrcDir
	include '**/*.tex'
	filter { line ->
		line.replace("@version@", bookVersion)
	}
	filter { line ->
		line.replace("@timestamp@", new SimpleDateFormat("dd.MM.yyyy HH:mm:ss").format(new Date()))
	}
}

task latexFirstRun(type: Exec, dependsOn: replaceVersionInfo) {
	commandLine 'pdflatex', '-output-directory', '.', 'text.tex'
	workingDir buildSrcDir
	ignoreExitValue true
	standardOutput = new ByteArrayOutputStream()
	doLast {
		if (execResult.getExitValue() != 0) {
			println standardOutput.toString()
			throw execResult.rethrowFailure()
		}
	}
}

task latexSecondRun(type: Exec, dependsOn: latexFirstRun) {
	commandLine 'pdflatex', '-output-directory', '.', 'text.tex'
	workingDir buildSrcDir
	ignoreExitValue true
	standardOutput = new ByteArrayOutputStream()
	doLast {
		if (execResult.getExitValue() != 0) {
			println standardOutput.toString()
			throw execResult.rethrowFailure()
		}
	}
}

task latexThirdRun(type: Exec, dependsOn: latexSecondRun) {
	commandLine 'pdflatex', '-output-directory', '.', 'text.tex'
	workingDir buildSrcDir
}

// Prüfe Vorgaben zur Texteingabe.
task checkTexFiles(dependsOn: replaceVersionInfo) {
	def inputFiles  = files { fileTree(dir: srcDir, includes: ['*.tex']) }
	inputs.files inputFiles
	doLast {
		println ""
		inputFiles.each { datei ->
			String fileContent = datei.text
			logger.info("Length of file ${datei.name} = ${fileContent.length()}")
			def lineCounter = 0
			fileContent.eachLine {
				lineCounter++
				// Mehrfache Leerzeichen.
				if (it =~ / +\n* +/) {
					logger.error("Error: ${datei.name}:${lineCounter}, mehrfache Leerzeichen: \"${it}\"")
				}
				// Leerzeichen am Zeilenanfang.
				if (it =~ /^ /) {
					logger.error("Error: ${datei.name}:${lineCounter}, Leerzeichen am Zeilenanfang: \"${it}\"")
				}
				// Leerzeichen am Zeilenende.
				if (it =~ /.+ $/) {
					logger.error("Error: ${datei.name}:${lineCounter}, Leerzeichen am Zeilenende: \"${it}\"")
				}
				// Tabulatorzeichen im Text.
				if (it =~ /\t/) {
					logger.error("Error: ${datei.name}:${lineCounter}, Tabulatorzeichen im Text: \"${it}\"")
				}
				// Falscher Trenner.
				if (it =~ /[^${b}]\\-[^${b}]/) {
					logger.error("Error: ${datei.name}:${lineCounter}, Falscher Trennstrich: \"${it}\"")
				}
				// Falscher Trenner am Zeilenende wenn mit % abgeschlossen ist.
				if ((it =~ /\\-[^${b}]%.*$/) || (it =~ /\\-%.+$/)) {
					logger.error("Error: ${datei.name}:${lineCounter}, Falscher Trennstrich am Zeilenende: \"${it}\"")
				}
				// Falscher Trenner am Zeilenende wenn nicht mit % abgeschlossen ist. Kommentarzeilen ignorieren.
				if (it =~ /^([^%]|\\%)*[^-%]+[\\]{0,1}-[ \t]*$/) {
					logger.error("Error: ${datei.name}:${lineCounter}, falscher Trennstrich am Zeilenende: \"${it}\"")
				}
			}
		}
	}
}

// Wörter finden, die die Ligatur enthalten und
// in der vorherigen Zeile begonnen haben können
// bzw. in der nächsten Zeile enden können.
// Zusammengesetzte Wörter mit "-" ebenfalls
// berücksichtigen.
task listLigations() {
	def inputFiles  = files { fileTree(dir: srcDir, includes: ['*.tex']) }
	inputs.files inputFiles

	doLast {
		def ligaturen = ['f', 't']
		def liste = []
		inputFiles.each {
			String fileContent = it.text

			ligaturen.each {
				def ligatur = "(${it}(\\-){0,1}${it})"
				def restSelbeZeile = "([${b}]|(\\-[${b}]))*"
				def trennerZeilenende = "(\\-%\n){0,1}"
				def restVorhZeile =
					"(${restSelbeZeile}${trennerZeilenende}){0,1}"
				def restNächsteZeile =
					"(${trennerZeilenende}${restSelbeZeile}){0,1}"
				
				def matcher =
					fileContent =~
						/${restVorhZeile}${restSelbeZeile}${ligatur}${restSelbeZeile}${restNächsteZeile}/

				matcher.each {
					String wort = it[0].replaceAll('\\\\-', '').replaceAll('%', '').replaceAll('\n', '')
					if (! liste.contains(wort)) { liste.add(wort) }
				}
			}
		}
		println "Im Text gefundene Ligaturwörter mit den Doppelbuchstaben von ${ligaturen}:\n"
		liste.sort{x, y -> x.compareToIgnoreCase y}.each {println it}
		println "\n${liste.size} Wörter"
	}
}

task pdf(dependsOn: latexThirdRun) {
	doLast { logger.info("PDF created.") }
}
