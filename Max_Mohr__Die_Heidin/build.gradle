import java.text.SimpleDateFormat

apply plugin: 'base'

defaultTasks 'pdf'

ext.srcDir = file 'src/main/latex'
ext.buildSrcDir = file 'build/src/main/latex'
ext.inputFile = 'text.tex'
ext.pdfDir = file 'build/pdf'

// Buchstaben.
def b = 'a-zA-ZÄÖÜäöüßçéèáà'

task replaceVersionInfo(type: Copy) {
	description = 'Replace the version information in the book.'
	from srcDir
	into buildSrcDir
	include '**/*.tex'
	filter { line ->
		line.replace("@version@", bookVersion)
	}
	filter { line ->
		line.replace("@timestamp@", new SimpleDateFormat("dd.MM.yyyy HH:mm:ss").format(new Date()))
	}
}

task resources(dependsOn: replaceVersionInfo) {
	outputs.file pdfDir
	doLast {
		pdfDir.mkdirs()
	}
}

task latex(dependsOn: ['resources', 'replaceVersionInfo']) {
	inputs.files replaceVersionInfo.outputs
	outputs.file pdfDir
	doLast {
		latexFirstRun.execute()
		latexSecondRun.execute()
		latexThirdRun.execute()
	}
}

task latexFirstRun(type: Exec) {
	commandLine 'pdflatex', '-output-directory', pdfDir, inputFile
	workingDir buildSrcDir
	ignoreExitValue true
	standardOutput = new ByteArrayOutputStream()
	doLast {
		logger.info 'LaTeX first run.'
		if (execResult.getExitValue() != 0) {
			println standardOutput.toString()
			throw execResult.rethrowFailure()
		}
	}
}

task latexSecondRun(type: Exec, dependsOn: latexFirstRun) {
	commandLine 'pdflatex', '-output-directory', pdfDir, inputFile
	workingDir buildSrcDir
	ignoreExitValue true
	standardOutput = new ByteArrayOutputStream()
	doLast {
		logger.info 'LaTeX second run.'
		if (execResult.getExitValue() != 0) {
			println standardOutput.toString()
			throw execResult.rethrowFailure()
		}
	}
}

task latexThirdRun(type: Exec, dependsOn: latexSecondRun) {
	commandLine 'pdflatex', '-output-directory', pdfDir, inputFile
	workingDir buildSrcDir
	doLast {
		logger.info 'LaTeX third run.'
	}
}

task stripLatexMarkup(dependsOn: replaceVersionInfo) {
	description = 'Convert all input LaTeX files to plain text files.'
	fileTree(dir: file('build'), include: '*.tex').each { file ->
		if (! file.text.contains('%%SuppressWarnings("ContentCheck")')) {
			doLast {
				exec {
					commandLine('bash', '-c', 'cat ' +
						file +
						// Am Zeilenende mit \-% getrennte Wörter hochziehen.
						//' | sed \':a;N;$!ba;s/\\\\-%\\n\\(['+b+']*[\\.,;: ]*\\)/\\1\\n/g\'' +
						' | sed \':a;N;$!ba;s/\\\\-%\\n\\(%[^\\n]*\\n\\)*\\(['+b+']*[\\.,;:!? ]*\\)/\\2\\1\\n/g\'' +
						
						// Am Zeilenende mit -% getrennte Wörter hochziehen.
						' | sed \':a;N;$!ba;s/\\(['+b+']-\\)%\\n\\(%[^\\n]*\\n\\)*\\(['+b+']*[\\.,;:!? ]*\\)/\\1\\3\\2\\n/g\'' +
				//						' | sed \':a;N;$!ba;s/(?<!\\\\)+-%\\n\\(%.+\\n\\)*\\([' + b + ']*[.,;:!? ]*\\)/-(a)\\2(b)\\n(c)\\1(d)/g\'' +
						// Trenner "- entfernen: detex erkennt sie nicht.
						' | sed \'s/"-//\'' +
						// Zeilenumbrüche //* entfernen: detex erkennt sie nicht.
						' | sed \'s/\\\\\\\\\\*//\'' +
						// \eingrif{...} \begin{...} \end{...} entfernen.
						
						// Remove remaining tex tags.
						/*' | detex -*/ ' > ' + file + '.txt')
				}
			}
		}
	}
}

// Prüfe Vorgaben zur Texteingabe.
task checkTexFiles(dependsOn: replaceVersionInfo) {
	description = 'Check the conformity of the input LaTeX files.'
	def inputFiles  = files { fileTree(dir: srcDir, includes: ['*.tex']) }
	inputs.files inputFiles
	doLast {
		println ""
		inputFiles.each { datei ->
			String fileContent = datei.text
			logger.info("Length of file ${datei.name} = ${fileContent.length()}")
			def lineCounter = 0
			try {
				fileContent.eachLine {
					lineCounter++
				
					// Aussteigen wenn Datei nicht geprüft werden soll.
					if (it =~ /^[ \t]*%%SuppressWarnings\("InputStyle"\)/) {
						throw new Exception("return from closure")
					}
					// Makros die nicht mit { enden.
					if (it =~ /\\[a-zA-Z]+[ \\\t\n\.,;:-]{1,1}/) {
						logger.error("Error: ${datei.name}:${lineCounter}, Makroname nicht mit { oder [ terminiert: \"${it}\"")
					}
					// Mehrfache Leerzeichen.
					if (it =~ / {2}/) {
						logger.error("Error: ${datei.name}:${lineCounter}, mehrfache Leerzeichen: \"${it}\"")
					}
					// Leerzeichen am Zeilenanfang.
					if (it =~ /^ /) {
						logger.error("Error: ${datei.name}:${lineCounter}, Leerzeichen am Zeilenanfang: \"${it}\"")
					}
					// Leerzeichen am Zeilenende.
					if (it =~ /.+ $/) {
						logger.error("Error: ${datei.name}:${lineCounter}, Leerzeichen am Zeilenende: \"${it}\"")
					}
					// Tabulatorzeichen im Text.
					if (it =~ /\t/) {
						logger.error("Error: ${datei.name}:${lineCounter}, Tabulatorzeichen im Text: \"${it}\"")
					}
					// Falscher Trenner.
					if (it =~ /[^${b}]\\-[^${b}]/) {
						logger.error("Error: ${datei.name}:${lineCounter}, Falscher Trennstrich: \"${it}\"")
					}
					// Falscher Trenner am Zeilenende wenn mit % abgeschlossen ist.
					if ((it =~ /\\-[^${b}]%.*$/) || (it =~ /\\-%.+$/)) {
						logger.error("Error: ${datei.name}:${lineCounter}, Falscher Trennstrich am Zeilenende: \"${it}\"")
					}
					// Falscher Trenner am Zeilenende wenn nicht mit % abgeschlossen ist. Kommentarzeilen ignorieren.
					if (it =~ /^([^%]|\\%)*[^-%]+[\\]{0,1}-[ \t]*$/) {
						logger.error("Error: ${datei.name}:${lineCounter}, falscher Trennstrich am Zeilenende: \"${it}\"")
					}
				}
			}
			catch (Exception e) {}
		}
	}
}

// Wörter finden, die die Ligatur enthalten und
// in der vorherigen Zeile begonnen haben können
// bzw. in der nächsten Zeile enden können.
// Zusammengesetzte Wörter mit "-" ebenfalls
// berücksichtigen.
task listLigations() {
	description = 'Find tokens that contain ligations, e. g. ff, fl, ...'
	def inputFiles  = files { fileTree(dir: srcDir, includes: ['*.tex']) }
	inputs.files inputFiles

	doLast {
		def ligaturen = [['f', 'f'], ['t', 't'], ['f', 'l']]
		def liste = []
		inputFiles.each {
			String fileContent = it.text

			ligaturen.each {
				def ligatur = "${it[0]}(\\-){0,1}${it[1]}"
				def restZeile = "([${b}]|(\\-[${b}]))"
				def restZeile0 = "${restZeile}*"
				def restZeile1 = "${restZeile}+"
				def trennerZeilenende = "\\-%\n"
				def vorherigeZeile =
					"(${restZeile1}${trennerZeilenende}){0,1}"
				def nächsteZeile =
					"(${trennerZeilenende}${restZeile1}){0,1}"
				
				def matcher =
					fileContent =~
						/${vorherigeZeile}${restZeile0}${ligatur}${restZeile0}${nächsteZeile}/

				matcher.each {
					String wort = it[0].replaceAll('\\\\-', '').replaceAll('%', '').replaceAll('\n', '')
					if (! liste.contains(wort)) { liste.add(wort) }
				}
			}
		}
		println "Im Text gefundene Ligaturwörter mit den Doppelbuchstaben von ${ligaturen}:\n"
		liste.sort{x, y -> x.compareToIgnoreCase y}.each {println it}
		println "\n${liste.size} Wörter"
	}
}


task cpdCheck(type: JavaExec, dependsOn: stripLatexMarkup) {
	description = 'Check for double text passages in the input files.'
	main 'net.sourceforge.pmd.cpd.CPD'
	classpath fileTree(dir: file('lib'), include: 'pmd*.jar')
	args = [
		'--minimum-tokens', minimumDuplicateTokens,
		'--format', 'xml',
		'--encoding', 'UTF-8',
		'--language', 'latex',
		'--files', file('build')
	]
	standardOutput = new ByteArrayOutputStream()
	ignoreExitValue true
	doLast {
		file('build/cpd.xml').write(standardOutput.toString())
	}
}

task tokenFind(dependsOn: stripLatexMarkup) {
	description = 'List all tokens found in the input files.'
	def inputFiles  = files { fileTree(dir: file('build'), includes: ['*.tex.txt']) }
	inputs.files inputFiles

	doLast {
		def liste = [:]
		inputFiles.each {
			def tokenizer = new StringTokenizer(it.text, "\n\r\f \t!?#\$%^&*()[]=+<>/;:.,", false)
			try {
				// Process all tokens of one line.
				for (def token = tokenizer.nextToken(); token != null; token = tokenizer.nextToken()) {
					if (token != '--') {
						if (liste.get(token)) { liste[token]++}
						else { liste[token] = 1 }
					}
				}
			} catch (NoSuchElementException ex) { /* Done with the line. */ }
		}
	
		println "${liste.size()} im Text gefundene Tokens:\n"
		liste.sort{it.key}.sort{it.value}.each{println "${it.value}".padLeft(4) + ": ${it.key}"}
	}

}

